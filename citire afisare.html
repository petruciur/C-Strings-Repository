<!DOCTYPE html>
<html>
<head>
<style>
body {
    margin: 0;
}

ul {
    list-style-type: none;
    margin: 0;
    padding: 0;
    width: 13%;
    background-color: #000000;
    position: fixed;
    height: 100%;
    overflow: auto;
    border: 3px solid #555;
	
}

li a {
    display: block;
    color: #FFFFFF;
    padding: 8px 10px;
    text-decoration: none;
	line-height: 7;
    text-align: center;
    border-bottom: 3px solid #555;
	
}

li a.acasa:hover {li {background: lightblue url("giphy 2.gif") no-repeat center;}
}


li a.blue:hover {
    background-color: #555;
    color: white;
	background: lightblue url("giphy 2.gif") no-repeat center;
}
li a.red:hover {
    background-color: #555;
    color: white;
	background: lightblue url("giphy.gif") no-repeat center;

}


.yellow {color: #FFFF99;}
.red {color:	#A52A2A;}
.blue 	{color: #00CED1;}
.purple {color: #DDA0DD;}
.button {
    background-color: #000000;
    color: white;
    padding: 67px 278.5px;
    text-decoration: none;
    display: inline-block;
    font-size: 16px;
    margin: 0px 0px;
    cursor: pointer;
    width: 71%;
}

h2{ text-align:center;
	margin-top: -100px;
	color: white;
	margin-left: 200px;
	font-family: Verdana, Geneva, sans-serif;
	text-size: 10px;
	}
h4 { text-align: center;
	 margin-top: 50px;
	 color:white;
	 margin-left: 200px;
	}
	body{
  background: #000;
} 
span{
  animation: blink 1s infinite;
}

@keyframes type{ 
  from { width: 0; } 
} 

@keyframes type2{
  0%{width: 0;}
  50%{width: 0;}
  100%{ width: 100; } 
} 

@keyframes blink{
  to{opacity: .1;}
}
p{color: lime;
  font-family: "Courier";
  font-size: 25px;
  white-space: nowrap;
  overflow: hidden;
  width: 64em;
  animation: type 2s steps(60, end); 
  margin-left:300px;
  white-space: pre;
  color: white;
  font-weight: 300%;
  line-height: 1;
  margin-top: 100px;
  margin-right: -150px;
  white-space: pre;
}

p:nth-child(1){
  animation: type2 1s steps(60, end);
} 
p:nth-child(2){
  animation: type2 3s steps(60, end);
}
p:nth-child(3){
  animation: type2 5s steps(60, end);
}
@-webkit-keyframes blink-caret {
    from, to { border-color: transparent }
    50% { border-color: black }
}



body {
	background: black;
	font-family: Verdana, Geneva, sans-serif;
	
	}

</style>
</head>
<body>

<ul>
<b>
  <li><a  class="acasa" href="pagina intrare.html" >Acasa</a></li>
  <li><a  href="def sir.html">Definitie</a></li>
  <li><a href="citire afisare.html">Citire si afisare</a></li>
  <li><a href="functii.html">Functii</a></li>
  <li><a href="Surse.html">Surse</a></li></b>
</ul>
<a class="button" ></a>

<h2>Siruri de caractere</h2>
<h4> Citiera / Afisarea sirurilor de caractere </h4>
<b>
<p>Sirurile de caractere pot fi initializate inca de la declarare sau citite pe parcursul programului.</p>
<p>	a.Citirea unui sir de caractere se poate face ca citirea oricarui tablou, intr-un for, caracter cu
caracter (desi nu este recomandata). In acest caz, terminatorul de sir nu este memorat automat, el
trebuie pus explicit dupa ultimul caracter din sir.
<u>Exemplu:</u>
char c[20];
for(int i=0;i < =5;i++)
cin >> c[i];
cout << c << endl; //se va afisa sirul format din cele 6 caractere, urmat de caractere „reziduale”,
//initializate implicit la compilare, din cauza ca n-a fost pus terminatorul de sir

c[6]=0;
cout << c << endl; // a fost pus terminatorul de sir, deci sirul va fi afisat corect </p>

<p>	b. Se poate face pur si simplu, folosind cin>>. Caracterul nul este adaugat automat.
Dezavantajul este ca in acest fel nu se pot citi siruri care contin mai multe cuvinte separate
prin spatii. Citirea sirului se sfarseste la intalnirea primului caracter blank (de ex, daca se
citeste “ora de informatica”, variabila c va retine numai “ora”).
<u>Exemplu:</u>
char c[30];
cin >> c;
cout << c;</p>

<p>	c. Se poate folosi o functie speciala pentru citirea sirurilor de caractere, inclusa in
biblioteca string.h (varianta recomandata).
<u>Exemplu:</u>
char a[30],x;int nr;
cin.get(a,nr,x);
Functia cin.get citeste un sir de caractere sau pana cand au fost citite nr-1 caractere, sau daca s-a
intalnit caracterul x. Al treilea parametru poate lipsi, caz in care el este implicit caracterul ’\n’
(new line). Sunt citite si caracterele albe, caracterul nul este inserat automat iar caracterul
transmis ca ultim parametru nu este inserat in sir.
<u>Exemplu:</u>
char a[30];
cin.get(a,5,’s’); //daca se citeste sirul “maimuta, variabila a va retine “maim”
cin.get(a,15,’s’); //daca se citeste sirul “maimuta, variabila a va retine “maimuta”
cin.get(a,15,’t’); //daca se citeste sirul “maimuta, variabila a va retine “maimu”
cin.get(a,4,’t’); //daca se citeste sirul “maimuta, variabila a va retine “mai”
cin.get(a,10); //daca se citeste sirul “maimuta, variabila a va retine “maimuta”

Functia cin.get( ) fara parametri are rolul de a citi un caracter (alb sau nu).
Functia cin.get(char c) are rolul de a citi un caracter (alb sau nu) pe care il incarca in variabila c.
Observatie: In cazul utilizarii repetate a functiei cin.get(a,nr,x), dupa fiecare folosire trebuie
citit caracterul de la sfarsitul fiecarui sir , adica ’\n’ (in caz contrar, acest caracter va fi incarcat la
inceputul urmatorului sir, a carui citire se termina la caracterul Enter, deci citirea celui de-al
doilea sir se termina inainte de a incepe, iar al doilea sir va fi sirul vid). Aceasta citire a
caracterului ’\n’ se realizeaza folosind cin.get() fara parametri.
<u>Exemplu:</u>
char a[30],b[30];
cin.get(a,15);
cin.get(b,10);
Daca se incearca citirea sirurilor „sarbatoare” si „vacanta”, se observa ca a=”sarbatoare”, b=””
(nici nu apucam sa citim sirul b). Varianta corecta este:
cin.get(a,15);
cin.get();
cin.get(b,10);
Afisarea unui sir de caractere se face folosind cout.
cout << a;

Se poate afisa si caracter cu caracter, ca in cazul tablourilor, dar aceasta varianta nu este
recomandata.
</p>
</b>



</body>
</html>

